#!/usr/bin/env node
const url = require('url')
const http = require('http')
const https = require('https')
const zlib = require('zlib')
const BufferList = require('bl')
const debug = require('debug')('mitmdump')
const HttpProxy = require('http-proxy')
const proxy = HttpProxy.createProxy()

const HTTP_PROXY = process.env.http_proxy || process.env.HTTP_PROXY
if (HTTP_PROXY) {
  debug(`using HTTP_PROXY: ${HTTP_PROXY}`)
  const HttpProxyAgent = require('http-proxy-agent')
  http.globalAgent = new HttpProxyAgent(HTTP_PROXY)
}

const middlewares = []

const valuableTypes = new Set([
  'text/plain',
  'text/html',
  'application/xhtml+xml',
  'application/xml',
  'application/javascript',
  'application/json'
])

function isValuable(message, estimated) {
  if (estimated && 'get' === message.method.toLowerCase()) {
    return true
  }
  let type = message.headers['content-type']
  if (!type) {
    return false
  }
  type = type.split(';')[0].toLowerCase()
  if (valuableTypes.has(type)) {
    return true
  }
  return false
}

const statusMoved = new Set([301, 302])

const unzip = {
  gzip    : zlib.createGunzip,
  deflate : zlib.createInflate
}

middlewares.push(async function() {

  const {client2proxy, proxy2client, options} = this

  if (!isValuable(client2proxy, true)) {
    return true
  }
  debug('try do MITM attack')

  const bl = new BufferList

  function buffer(source, buffer) {
    return new Promise((resolve) => {
      source.on('end', resolve)
      source.pipe(buffer)
      source.resume()
    })
  }

  await buffer(client2proxy, bl)

  const record = {
    request: Object.assign({}, options, {body: bl.toString()}),
    responses: []
  }

  const request = (async (protocol) => {
    const message = await this.request(protocol, bl.duplicate())
    const {statusCode, headers} = message
    const result = {message, stream: message}

    const response = {statusCode, headers}
    if (isValuable(message)) {

      debug('valuable attack')
      const origin = new BufferList
      await buffer(message, origin)
      const shallow = origin.duplicate()
      let output = new BufferList
      const encoding = message.headers['content-encoding']
      if (encoding) {
        const createStream = unzip[encoding.toLowerCase()]
        if (createStream) {
          await new Promise((resolve) => {
            const unzipStream = createStream()
            unzipStream.on('end', resolve)
            shallow.pipe(unzipStream).pipe(output);
          })
        }
      } else {
        output = shallow
      }
      //console.log(origin.length, output.length);
      result.stream = origin
      response.body = output.toString()
      headers['x-mitm-valuable'] = true

    }
    record.responses.push(response)

    return result
  })

  let server2proxy = await request(http)

  if (statusMoved.has(server2proxy.message.statusCode)) {
    const location = url.parse(server2proxy.message.headers.location)
    const [host, port] = location.host.split(':')
    if ('https:' === location.protocol) {
      if (options.host === host &&
          options.path === location.path) {
        options.port = null
        server2proxy.message.destroy()
        server2proxy = await request(https)
      }
    }
  }

  {
    const {statusCode, headers} = server2proxy.message
    proxy2client.writeHead(statusCode, headers)
    server2proxy.stream.pipe(proxy2client)
    server2proxy.stream.resume()
  }

  //console.log(record);

})

middlewares.push(async function() {

  debug('pipe everythinig')

  //const target = `http://${this.options.host}${this.options.path}`
  //proxy.web(this.client2proxy, this.proxy2client, {target})

  const {proxy2client} = this
  const server2proxy = await this.request(http)
  const {statusCode, headers} = server2proxy
  proxy2client.writeHead(statusCode, headers)
  server2proxy.pipe(proxy2client)
  server2proxy.resume()

})

class Context {
  constructor(client2proxy, proxy2client) {
    this.client2proxy = client2proxy
    this.proxy2client = proxy2client

    const headers = Object.keys(client2proxy.headers)
    .filter(key => !/^proxy-/.test(key))
    .reduce((headers, key) => {
      headers[key] = client2proxy.headers[key]
      return headers
    }, Object.create(null))
    const {method} = client2proxy
    const {path} = url.parse(client2proxy.url)
    const [host, port] = client2proxy.headers.host.split(':')
    headers.host = host
    this.options = { method, path, host, headers }
  }

  async execute() {
    for (const middleware of middlewares) {
      const next = await middleware.call(this)
      if (!next) {
        break
      }
    }
  }

  async request(protocol, body) {
    if (!body) {
      body = this.client2proxy
      body.resume()
    }
    return new Promise((resolve, reject) => {
      const proxy2server = protocol.request(this.options, (response) => {
        response.pause()
        resolve(response)
      })
      body.pipe(proxy2server)
    })
  }

}

const server = http.createServer(async(client2proxy, proxy2client) => {

  try {
    context = new Context(client2proxy, proxy2client)
    await context.execute()
  } catch (e) {
    console.error(e.stack);
  }

})

server.on('upgrade', (request, socket, head) => {
  const {path} = url.parse(request.url)
  //const [host, port] = request.headers.host.split(':')
  const target = `ws://${request.headers.host}${path}`
  debug(`upgrade: ${target}`)
  proxy.ws(request, socket, head, {target})
})


server.listen(process.env.PORT, '0.0.0.0')
module.exports = server
